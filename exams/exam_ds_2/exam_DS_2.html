<p></p>
<h1 id="data-structures-questions">Data Structures Questions</h1>
<ol>
<li>Implement the function <code>Node* Flip(Node *)</code> which reverses the order of the elements in a singly-linked list
<ol>
<li>Implement the function iteratively</li>
<li>Implement the function recursively</li>
</ol></li>
<li><p>Write a function finding contiguous subarray within a one-dimensional array of numbers(integers) which has a largest sum. For example, for sequence -2,1,-3,4,-1,2,1,-5,4; the contiguous subarray with largest sum is 4,-1,2,1 with sum 6. The run time complexity of your function should be O(n).</p></li>
<li><p>Write a function sort_stack which sorts the contents of a stack.</p></li>
<li><p>Write a function that sorts the characters contained in a file:<br>
<code>int sort_chars_in_file(const char *file_name, char *result);</code></p></li>
<li>Implement the following functions for a binary tree containing <code>int</code>:
<ol>
<li><code>insert</code> // (iteratively)</li>
<li><code>insert</code> // (recursively)</li>
<li><code>insert</code> // (for a binary tree represented as a fixed size array)</li>
</ol></li>
<li><p>What is a heuristic? Provide an example</p></li>
<li><p>Write a recursive function that reverses a string.</p></li>
<li><p>Write a function that produces all permutations of a string.<br>
Example: "eat" produces: eat, eta, tea, tae, ate, aet</p>
<ol>
<li>How would you solve the following: Given a word, which words may be generated from the letters in the original word? Example: "bored" can produce bore, bode, rob, rod, rode, ore, ode, red, bred, bed, etc</li>
<li>How would you do the same for each word in a list of words, ensuring that you do not generate the same word more than once.</li>
</ol></li>
<li><p>You have a large collection of 32 bit addresses. What is the quickest way to determine if you already have a given address?</p></li>
<li><p>Write a function stack_insert which keeps the contents of the stack sorted (from lowest to highest). Do not use a second stack structure.</p></li>
</ol>